文件IO(系统调用IO)是每次操作都会执行系统调用,标准IO实现了进程内数据缓存,并不会每次都直接执行系统调用

# fd文件描述符，是贯穿文件IO始终的类型

	文件描述符的概念（实质是一个整数，是数组的下标，文件描述符优先使用当前可用范围内最小的）
	数组存放在**进程空间**的，每个进程都有这样一个数组，不同的进程打开同一个文件，每个进程都会有一个文件结构体，但最终指向的inode文件唯一标识符是相同的。
	由于两个结构体在不同的进程中，所以两个结构体是互相不影响的，但最终操作的是同一个文件，会产生竞争和冲突问题。

	同一个文件在一个进程中被打开多次，每次都会产生一个结构体，结构体之间也不会互相影响（甚至可以相互配合配合对文件进行读写）.
	既然数组中存放的是结构体的地址，那么有可能不同的数组下标存放的是同一块结构体的地址（如下标3、5存放的结构体地址相同），那么在关闭3后，这块
	结构体内存并不会立即释放（如果立即释放，则下标5的指针就成为了野指针），那么就要求结构体肯定有一个引用计数，表示当前有几个指针指向它自己，
	只有当引用计数为0时，才真正释放这块内存区域。

	标准IO的FILE结构体肯定会有系统IO中的文件描述符标志，因为标准IO是建立在系统IO之上，系统IO每个文件的打开都会有系统IO的结构体和文件描述符。

# 文件IO操作：open,close,read,write,lseek(之前的标准IO都是依赖这几个函数)

	int open(const char *pathname, int flags);
	（cache是加速读的机制，buffer是加速写的机制）
	参数flags必须包含以下模式的其中之一：O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（读写）。
	另外文件创建模式的flags和文件状态模式的flags可以任选0个或多个进行按位或运算，来作为flags。
	文件创建模式的flags有：O_CREAT（创建）、O_EXCL（存在）、O_NOCTTY（终端设备）、O_TRUNC（截断）。

	对应标准IO的模式： r --> O_RDONLY
						r+ --> O_RDWR
						w --> O_WRONLY | O_CREAT | O_TRUNC
						w+ --> O_RDWR | O_CREAT | O_TRUNC
						a --> O_WRONLY | O_CREAT | O_APPEND ？
						a+ --> O_RDWR | O_CREAT | O_APPEND ？
	flags表示位图
	
# 文件IO和标准IO的区别
	两者转换函数 fileno();
				 fdopen();
			 
	虽然可以相互转换，标准IO与文件IO不可混用，为什么？
		因为标准IO的FILE结构体和fd对应的结构体，其position位置是不同的。
		strace 命令可查看可执行文件的系统调用

#IO的效率问题
	BUFSIZE的大小变化时，读写的效率不同，使用time命令查看耗时real user sys，一般情况下16MB就会报段错误，这是由于C的内存分布造成的
	性能最佳拐点是在哪里？
	
	BUFSIZE 1024      2048       4096       8192       16384(16K)    1024*1024   1M *  2      1M * 4    1M*6           1M * 8
	real	0m2.136s  0m1.320s   0m1.263s   0m1.070s   0m0.997s      0m1.059s    0m1.112s     0m1.016s    0m1.055s       段错误
	user	0m0.342s  0m0.116s   0m0.097s   0m0.053s   0m0.021s      0m0.001s    0m0.001s     0m0.002s    0m0.000s
	sys	    0m1.257s  0m0.917s   0m0.678s   0m0.657s   0m0.594s      0m0.584s    0m0.599s     0m0.631s    0m0.664s
	
	
	这里8M就报段错误，因为查看ulimit -a中 stack size              (kbytes, -s) 8192， 栈空间为8M大小。
	 
	

# 文件共享
	题目：写程序，删除一个文件的第10行。可以在一个进程或多个进程中打开同一个文件，一个对其读，一个对其写。
	补充函数： truncate/ftruncate

# 原子操作
原子：不可分割的最小单位
原子操作：不可分割的操作
作用：解决竞争和冲突
样例：tmpnam（只给一个文件名）tmpfile（）

# 程序中的重定向： dup, dup2
在代码中要将一个puts输出到指定文件，则需要将stdout重定向。
可以先关闭1的文件，再打开fd，这样用的就是1号。（但如果没有1号怎么办？）
int dup2(int oldfd, int newfd); 是原子操作


# 同步：sync, fsync, fdatasync
将设备解除挂载时刷新buffer
fdatasync：同步一个文件，只刷数据，不刷亚数据

fcntl(): 与文件描述符所变的魔术几乎都来源于此函数
ioctl()：设备相关的内容

/dev/fd/目录与文件描述符相关
是个虚目录，显示的是当前文件描述符的信息（哪个进程看，就显示哪个进程的文件描述符）


# 